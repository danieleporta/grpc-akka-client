
// Generated by Akka gRPC. DO NOT EDIT.
package io.grpc.channelz.v1

import scala.concurrent.ExecutionContext

import akka.grpc.scaladsl.{ GrpcExceptionHandler, GrpcMarshalling }
import akka.grpc.Codecs

import akka.http.scaladsl.model.{ HttpRequest, HttpResponse, StatusCodes }
import akka.http.scaladsl.model.Uri.Path
import akka.http.scaladsl.model.Uri.Path.Segment
import akka.actor.ActorSystem
import akka.stream.Materializer




  object ChannelzHandler {
    private val notFound = scala.concurrent.Future.successful(HttpResponse(StatusCodes.NotFound))

    /**
     * Creates a `HttpRequest` to `HttpResponse` handler that can be used in for example `Http().bindAndHandleAsync`
     * for the generated partial function handler and ends with `StatusCodes.NotFound` if the request is not matching.
     *
     * Use `akka.grpc.scaladsl.ServiceHandler.concatOrNotFound` with `ChannelzHandler.partial` when combining
     * several services.
     */
    def apply(implementation: Channelz)(implicit mat: Materializer, system: ActorSystem): HttpRequest => scala.concurrent.Future[HttpResponse] =
      partial(implementation).orElse { case _ => notFound }

    /**
     * Creates a `HttpRequest` to `HttpResponse` handler that can be used in for example `Http().bindAndHandleAsync`
     * for the generated partial function handler and ends with `StatusCodes.NotFound` if the request is not matching.
     *
     * Use `akka.grpc.scaladsl.ServiceHandler.concatOrNotFound` with `ChannelzHandler.partial` when combining
     * several services.
     */
    def apply(implementation: Channelz, eHandler: ActorSystem => PartialFunction[Throwable, io.grpc.Status])(implicit mat: Materializer, system: ActorSystem): HttpRequest => scala.concurrent.Future[HttpResponse] =
      partial(implementation, Channelz.name, eHandler).orElse { case _ => notFound }

    /**
     * Creates a `HttpRequest` to `HttpResponse` handler that can be used in for example `Http().bindAndHandleAsync`
     * for the generated partial function handler and ends with `StatusCodes.NotFound` if the request is not matching.
     *
     * Use `akka.grpc.scaladsl.ServiceHandler.concatOrNotFound` with `ChannelzHandler.partial` when combining
     * several services.
     *
     * Registering a gRPC service under a custom prefix is not widely supported and strongly discouraged by the specification.
     */
    def apply(implementation: Channelz, prefix: String)(implicit mat: Materializer, system: ActorSystem): HttpRequest => scala.concurrent.Future[HttpResponse] =
      partial(implementation, prefix).orElse { case _ => notFound }

    /**
     * Creates a `HttpRequest` to `HttpResponse` handler that can be used in for example `Http().bindAndHandleAsync`
     * for the generated partial function handler and ends with `StatusCodes.NotFound` if the request is not matching.
     *
     * Use `akka.grpc.scaladsl.ServiceHandler.concatOrNotFound` with `ChannelzHandler.partial` when combining
     * several services.
     *
     * Registering a gRPC service under a custom prefix is not widely supported and strongly discouraged by the specification.
     */
    def apply(implementation: Channelz, prefix: String, eHandler: ActorSystem => PartialFunction[Throwable, io.grpc.Status])(implicit mat: Materializer, system: ActorSystem): HttpRequest => scala.concurrent.Future[HttpResponse] =
      partial(implementation, prefix, eHandler).orElse { case _ => notFound }

    /**
     * Creates a partial `HttpRequest` to `HttpResponse` handler that can be combined with handlers of other
     * services with `akka.grpc.scaladsl.ServiceHandler.concatOrNotFound` and then used in for example
     * `Http().bindAndHandleAsync`.
     *
     * Use `ChannelzHandler.apply` if the server is only handling one service.
     *
     * Registering a gRPC service under a custom prefix is not widely supported and strongly discouraged by the specification.
     */
    def partial(implementation: Channelz, prefix: String = Channelz.name, eHandler: ActorSystem => PartialFunction[Throwable, io.grpc.Status] = GrpcExceptionHandler.defaultMapper)(implicit mat: Materializer, system: ActorSystem): PartialFunction[HttpRequest, scala.concurrent.Future[HttpResponse]] = {
      implicit val ec: ExecutionContext = mat.executionContext
      import Channelz.Serializers._

      def handle(request: HttpRequest, method: String): scala.concurrent.Future[HttpResponse] = method match {
        
        case "GetTopChannels" =>
          val responseCodec = Codecs.negotiate(request)
          
          GrpcMarshalling.unmarshal(request)(GetTopChannelsRequestSerializer, mat)
            .flatMap(implementation.getTopChannels(_))
            .map(e => GrpcMarshalling.marshal(e, eHandler)(GetTopChannelsResponseSerializer, mat, responseCodec, system))
        
        case "GetServers" =>
          val responseCodec = Codecs.negotiate(request)
          
          GrpcMarshalling.unmarshal(request)(GetServersRequestSerializer, mat)
            .flatMap(implementation.getServers(_))
            .map(e => GrpcMarshalling.marshal(e, eHandler)(GetServersResponseSerializer, mat, responseCodec, system))
        
        case "GetServer" =>
          val responseCodec = Codecs.negotiate(request)
          
          GrpcMarshalling.unmarshal(request)(GetServerRequestSerializer, mat)
            .flatMap(implementation.getServer(_))
            .map(e => GrpcMarshalling.marshal(e, eHandler)(GetServerResponseSerializer, mat, responseCodec, system))
        
        case "GetServerSockets" =>
          val responseCodec = Codecs.negotiate(request)
          
          GrpcMarshalling.unmarshal(request)(GetServerSocketsRequestSerializer, mat)
            .flatMap(implementation.getServerSockets(_))
            .map(e => GrpcMarshalling.marshal(e, eHandler)(GetServerSocketsResponseSerializer, mat, responseCodec, system))
        
        case "GetChannel" =>
          val responseCodec = Codecs.negotiate(request)
          
          GrpcMarshalling.unmarshal(request)(GetChannelRequestSerializer, mat)
            .flatMap(implementation.getChannel(_))
            .map(e => GrpcMarshalling.marshal(e, eHandler)(GetChannelResponseSerializer, mat, responseCodec, system))
        
        case "GetSubchannel" =>
          val responseCodec = Codecs.negotiate(request)
          
          GrpcMarshalling.unmarshal(request)(GetSubchannelRequestSerializer, mat)
            .flatMap(implementation.getSubchannel(_))
            .map(e => GrpcMarshalling.marshal(e, eHandler)(GetSubchannelResponseSerializer, mat, responseCodec, system))
        
        case "GetSocket" =>
          val responseCodec = Codecs.negotiate(request)
          
          GrpcMarshalling.unmarshal(request)(GetSocketRequestSerializer, mat)
            .flatMap(implementation.getSocket(_))
            .map(e => GrpcMarshalling.marshal(e, eHandler)(GetSocketResponseSerializer, mat, responseCodec, system))
        
        case m => scala.concurrent.Future.failed(new NotImplementedError(s"Not implemented: $m"))
      }

      Function.unlift((req: HttpRequest) => req.uri.path match {
        case Path.Slash(Segment(`prefix`, Path.Slash(Segment(method, Path.Empty)))) â‡’
          Some(handle(req, method).recoverWith(GrpcExceptionHandler.default(eHandler(system))))
        case _ =>
          None
      })
    }
  }

